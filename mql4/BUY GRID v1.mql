#property strict

/**
    v0.2, 18 Dec 2022
    Prototype of Grid Bot - similar to 3Commas Grid Bot
    Opens buy order every inNextPositionByPoints and sets Take Profit of takeProfitPoints.
    It has some bugs (like pyramiding  not working)
    Good candidate can be NASDAQ being close to the bottom, maybe OIL as well.
    Profitable but requires big depo and needs a few additions.
*/

#include <stdlib.mqh>
#include <ArraySortStruct.mqh>

input string expertName = "GRID buy*2";
input int expertId = 8;

input double takeProfitPoints = 10;
input double inPositionsSize = 0.01; //how big positions to open
input double inNextPositionByPoints = 10;
input double maxSellPrice = 0.;
input double minBuyPrice = 10000.; // Price at which Account Margin will be 100% (used for positionSize calculation)
input int positionLimitsToOpen = 15;

input double sellPositionSize = 0.50; //SELL position size
input int sellPositionsToOpen = 2; //How many SELLs to keep open
input double nextSellPositionByPoints = 200;

input bool piramide = false;

// Stoch params
input int stoch_K_Period = 14;
input int stochTop = 79;
input int stochBtm = 20;


string comment = "";

class Position
  {
public:
   int ticket;
   double lots;
   double profit;
   double openPrice;
   double stopLoss;
   //--- Default constructor
                     Position(){ ticket = -1; lots = 0.; profit = 0.; openPrice = 0.; stopLoss = 0.;};
   //--- Parametric constructor
   Position(int p_ticket, double p_lots, double p_profit, double p_openPrice, double p_stopLoss){
      ticket = p_ticket;
      lots = p_lots;
      profit = p_profit;
      openPrice = p_openPrice;
      stopLoss = p_stopLoss;
   }
};

Position buyPositions[]; //sorted by openPrice Asc
Position limitPositions[];
Position sellPositions[];

int totalBuyPositions = 0;
int totalLimitPositions = 0;
int totalSellPositions = 0;

double nextPositionByPoints = 0.;
bool inactive = false;
double positionSize = 0;


extern int Corner = 2;
extern int Move_X = 0;
extern int Move_Y = 0;
extern string B00001 = "============================";
extern int Button_Width = 30;
extern string Font_Type = "Arial Bold";
extern color Font_Color = clrWhite;
extern int Font_Size = 8;

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void OnInit(void)
  {

     double askPrice = MarketInfo(Symbol(), MODE_ASK);
     nextPositionByPoints = inNextPositionByPoints;
     positionSize = inPositionsSize > 0 ? inPositionsSize : calculatePositionSize();
     OnTick();
  }

void OnDeinit(const int reason)
  {
  }


//+------------------------------------------------------------------+

//|
//+------------------------------------------------------------------+
void OnTick(void)
  {
    double bidPrice = MarketInfo(Symbol(), MODE_BID);

    comment = "";
    readPositions();

    calculate();

    if (ordersTotal != totalBuyPositions + totalSellPositions){
      OnTrade();
      ordersTotal = totalBuyPositions + totalSellPositions;
    }

    Comment(comment);
}

void readPositions(){
    ArrayFree(buyPositions);
    ArrayFree(limitPositions);
    ArrayFree(sellPositions);

   for (int i = OrdersTotal() - 1; i >= 0; i--) {
      if (OrderSelect(i, SELECT_BY_POS, MODE_TRADES) && (expertId == OrderMagicNumber() || expertId == 0) && _Symbol == OrderSymbol()) {
         Position* p = new Position(OrderTicket(), OrderLots(), OrderProfit(), OrderOpenPrice(), OrderStopLoss());
         if (OrderType() == OP_BUY) {
            ArrayAppend(buyPositions, p);
         } else if (OrderType() == OP_BUYLIMIT){
            ArrayAppend(limitPositions, p);
         } if (OrderType() == OP_SELL) {
            ArrayAppend(sellPositions, p);
         }
         delete p;
      }
   }
   ArraySortStruct(buyPositions, openPrice);
   ArraySortStruct(limitPositions, openPrice);
   ArraySortStruct(sellPositions, openPrice);

   totalBuyPositions = ArraySize(buyPositions);
   totalSellPositions = ArraySize(sellPositions);
   totalLimitPositions = ArraySize(limitPositions);
}

void OnTrade(){
  //calculatePositionSize();
}

void ArrayAppend(Position & array[], Position & position){
   int newSize = ArraySize(array) + 1;
   ArrayResize(array, newSize, 10);
   array[newSize-1] = position;
}

int ordersTotal = OrdersTotal();

//+------------------------------------------------------------------+
//|                                                                  |
//+------------------------------------------------------------------+
void calculate()
{
   stochDoubleSellLogic();
   openOrdersLogic();
}

void openOrdersLogic(){
   double totalProfit = 0.;

   for (int i=totalBuyPositions-1; i>=0; i--){
      totalProfit += buyPositions[i].profit;
   }

   comment += ", SELL: " + totalSellPositions + ", BUY: " + totalBuyPositions + ", Pending BUY: " + totalLimitPositions + ", Profit: " + DoubleToStr(totalProfit,2) + " EQ: " + DoubleToStr(AccountEquity(),2);

   double askPrice = MarketInfo(Symbol(), MODE_ASK);
   // Place initial Orders
   if (totalBuyPositions + totalLimitPositions  == 0) {
      openOrder(OP_BUY);
      if (sellPositionsToOpen > 0){
         openOrder(OP_SELL);
      }
   } else  {
      double nextOpenPrice;
      // Append new BuyLimits if missing

      int toOpenCnt = positionLimitsToOpen - totalLimitPositions;
      if (totalLimitPositions > 0){
         nextOpenPrice = limitPositions[0].openPrice - nextPositionByPoints;
         if (totalBuyPositions > 0){
            int buyGapSize = MathRound((buyPositions[0].openPrice - limitPositions[totalLimitPositions-1].openPrice) / nextPositionByPoints) - 1;
            if (buyGapSize > 0){
               //there is a buyLimit gap caused by some best buy orders closed as a rescue
               nextOpenPrice = buyPositions[0].openPrice - nextPositionByPoints;
               toOpenCnt = buyGapSize;
            }
         }
      } else {
         nextOpenPrice = buyPositions[0].openPrice - nextPositionByPoints;
      }

      nextOpenPrice = MathMin(nextOpenPrice, askPrice); //current price much lower scenario
      for (int j=0; j < toOpenCnt; j++) {
         openOrder(OP_BUYLIMIT, nextOpenPrice);
         nextOpenPrice -= nextPositionByPoints;
      }
   }

     if (piramide && totalBuyPositions > 0 && totalLimitPositions > 0) {
      // Price goes in profitable dicection (piramide) scenario, open opposite orders as well if too few of them

      double nextPiramideOpenPrice = NormPrice(buyPositions[totalBuyPositions-1].openPrice + nextPositionByPoints);
      if (askPrice >= nextPiramideOpenPrice) {
         openOrder(OP_BUY);
      }
   }
}

void openOrder(int type, double price = 0){
   if (positionSize == 0){
       calculatePositionSize();
   }
   if (positionSize == -1){
      return;
   }
   if (type == OP_BUY || type == OP_BUYLIMIT){
      if (price == 0) price = Ask;
         OrderSend(_Symbol, type, positionSize, price, 0.001*Ask, 0, NormPrice(price + takeProfitPoints), expertName + " " + expertId, expertId, 0, Green);
   } else if (type == OP_SELL || type == OP_SELLLIMIT) {
      if (price == 0) price = Bid;
         OrderSend(_Symbol, type, sellPositionSize, price, 0.01*Bid, 0, 0, expertName + " " + expertId, expertId, 0, Red);
   }
}


double NormPrice(double price) {
   double tickSize = MarketInfo(Symbol(), MODE_TICKSIZE);
   return( MathRound(price/tickSize)*tickSize );
}

double calculatePositionSize(){
      double bidPrice = MarketInfo(Symbol(), MODE_BID);
      double askPrice = MarketInfo(Symbol(), MODE_ASK);
      double pointValuePerLot = MarketInfo(_Symbol, MODE_TICKVALUE) / MarketInfo(_Symbol, MODE_TICKSIZE);
      double maxAdditionalLoss = 0;
      double totalOpenedLots = 0;
      for (int i=0; i < totalBuyPositions; i++){
         totalOpenedLots = buyPositions[i].lots;
      }
      maxAdditionalLoss = (minBuyPrice-bidPrice) * totalOpenedLots * pointValuePerLot;
      comment += " Max additional loss: " + DoubleToStr(maxAdditionalLoss,2) + "@" + minBuyPrice;

      double equityAtLowestPrice = AccountEquity()+maxAdditionalLoss;
      double marginRequredAtLowestPrice = MarginAtMinBuyPrice(totalOpenedLots, pointValuePerLot);

      comment += " equityAtLowestPrice: " + DoubleToStr(equityAtLowestPrice,2) + " marginRequredAtLowestPrice: " + DoubleToStr(marginRequredAtLowestPrice,2) ;

      double nextOpenPrice = totalBuyPositions > 0 ? buyPositions[0].openPrice - nextPositionByPoints : askPrice;
      int positionsToOpen = MathFloor((nextOpenPrice - minBuyPrice)/nextPositionByPoints + 1);

      comment += " positionsToOpen: " + positionsToOpen;

      // 9936-2 = margin(0.01*635) + (12352-6000)*0.01*635*1
      // 9934 = 0.002*635*1*6000/30 + 6352*0.002*635*1
      // (9936-2) / (635*1*6000/30 + 6352*635*1) = 0.02
      // equityAtLowestPrice - marginRequredAtLowestPrice = marginRequredAtLowestPrice(newPositionsSize? * positionsToOpen)+ (askPrice-minBuyPrice) * newPositionsSize? * positionsToOpen * pointValuePerLot
      // = >
      double newPositionsSize = (equityAtLowestPrice - marginRequredAtLowestPrice) / (positionsToOpen * pointValuePerLot * minBuyPrice / AccountLeverage() + ((askPrice-minBuyPrice)*positionsToOpen*pointValuePerLot));
      newPositionsSize = MathFloor(newPositionsSize / MarketInfo(_Symbol, MODE_LOTSTEP)) * MarketInfo(_Symbol, MODE_LOTSTEP);

      positionSize = newPositionsSize == 0 ? -1 : newPositionsSize;
      comment += " NewPositionSize: " + DoubleToStr(positionSize,2) + " lotstep: " + MarketInfo(_Symbol, MODE_LOTSTEP);
      return positionSize;
}

double MarginAtMinBuyPrice(double lots, double pointValuePerLot)
{
   return lots * pointValuePerLot * minBuyPrice / AccountLeverage();
}

void stochDoubleSellLogic(){
     //open SELL orders on SELL signal
   if (sellPositionsToOpen > 0) {
      double bidPrice = MarketInfo(Symbol(), MODE_BID);
      double nextSellPrice = totalSellPositions == 0 ? bidPrice : NormPrice(sellPositions[totalSellPositions-1].openPrice + nextSellPositionByPoints);

      comment += "NextSell: " + nextSellPrice;
      if (bidPrice >= nextSellPrice && stochSignal(PERIOD_M15) == "sell") {
         openOrder(OP_SELL);
      }
   }
}

string stochSignal(int period) {
   string signal = NULL;

   int D_Period = 3;
   int Slowing = 3;
    //double ClosePriceYesterday = ClosePriceYesterday();
    double stoch_K0 = iStochastic(_Symbol, period, stoch_K_Period, D_Period, Slowing, MODE_SMA, 0, MODE_MAIN, 0); //current
    double stoch_D0 = iStochastic(_Symbol, period, stoch_K_Period, D_Period, Slowing, MODE_SMA, 0, MODE_SIGNAL, 0); //current
    double stoch_K1 = iStochastic(_Symbol, period, stoch_K_Period, D_Period, Slowing, MODE_SMA, 0, MODE_MAIN, 1); //last
    double stoch_D1 = iStochastic(_Symbol, period, stoch_K_Period, D_Period, Slowing, MODE_SMA, 0, MODE_SIGNAL, 1); //last

   //Comment("K0: " + stoch_K0 + " D0: " + stoch_D0 + " K1: " + stoch_K1 + " D1: " + stoch_D1);

    if (stoch_K0 > stochTop && stoch_D0 > stochTop)
      if (stoch_D0 > stoch_K0 && stoch_D1 < stoch_K1){
         signal = "sell";
      }

    if (stoch_K0 < stochBtm && stoch_D0 < stochBtm)
      if (stoch_D0 < stoch_K0 && stoch_D1 > stoch_K1) {
         signal = "buy";
      }
    return signal;
}